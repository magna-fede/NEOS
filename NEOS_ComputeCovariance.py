#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 15 15:21:50 2023

@author: fm02
"""

import sys
import os
from os import path

import numpy as np
import pandas as pd

import mne
from mne.preprocessing import ICA, create_eog_epochs
import seaborn as sns
import matplotlib.pyplot as plt

os.chdir("/home/fm02/MEG_NEOS/NEOS")
import NEOS_config as config

#os.chdir("/home/fm02/MEG_NEOS/NEOS/my_eyeCA")
from my_eyeCA import preprocess, ica, snr_metrics, apply_ica

os.chdir("/home/fm02/MEG_NEOS/NEOS")

mne.viz.set_browser_backend("matplotlib")

# %%

def compute_covariance(sbj_id, cov_method='empirical', save_covmat=False, plot_covmat=False):
    
    subject = str(sbj_id)
    
    ovr = config.ovr_procedure
    
    sbj_path = path.join(config.data_path, config.map_subjects[sbj_id][0])
    bad_eeg = config.bad_channels_all[sbj_id]['eeg']
    
    if ovr[sbj_id] == 'ovrons':
        over = '_ovrwonset'
        ica_dir = path.join(sbj_path, 'ICA_ovr_w_onset')
    elif ovr[sbj_id] == 'ovr':
        over = '_ovrw'
        ica_dir = path.join(sbj_path, 'ICA_ovr_w')
    elif ovr[sbj_id] == 'novr':
        over = ''
        ica_dir = path.join(sbj_path, 'ICA')
    condition = 'both'

    raw_test = []
    
    ica_sub = '_sss_f_raw_ICA_extinfomax_0.99_COV_None'
    ica_sub_file = '_sss_f_raw_ICA_extinfomax_0.99_COV_None-ica_eogvar'
            
    for i in range(1, 6):
        ica_fname = path.join(ica_dir,
                              f'block{i}'+ica_sub,
                              f'block{i}'+ica_sub_file) 
        raw = mne.io.read_raw(path.join(sbj_path, f"block{i}_sss_f_raw.fif"))
        evt_file = path.join(sbj_path, config.map_subjects[sbj_id][0][-3:] + \
                          f'_all_events_block_{i}.fif')
        evt = mne.read_events(evt_file)
        # hey, very important to keep overwrite_saved as false, or this will change
        # the raw files saved for checking which approach is best for each participant
        raw_ica, _, _ = apply_ica.apply_ica_pipeline(raw=raw,                                                                  
                        evt=evt, thresh=1.1, method='both',
						ica_filename=ica_fname, overwrite_saved=False)
        raw_test.append(raw_ica)
    
    raw_test = mne.concatenate_raws(raw_test)
    raw_test = raw_test.set_eeg_reference(ref_channels='average', projection=True)
    raw_test.load_data()
    raw_test.info['bads'] = bad_eeg
    raw_test.interpolate_bads(reset_bads=True)
    
    raw_test.drop_channels(['EEG004', 'EEG008'])
    
    picks = mne.pick_types(raw_test.info, meg=True, eeg=True, exclude='bads')

    target_evts = mne.read_events(path.join(sbj_path, config.map_subjects[sbj_id][0][-3:] + \
                              '_target_events.fif'))
    

    target_evts = mne.read_events(path.join(sbj_path, config.map_subjects[sbj_id][0][-3:] + \
                              '_target_events.fif'))
  

    # manually checked for the shortest possible time the fixation cross was on
    # this is 
    evt = pd.DataFrame(target_evts, columns=['time','n','trigger'])
    
    # we need to consider 34ms delay for those triggers that reflect a change in the display
    # note that we don't need to add the delay for the eye events (fixation/saccades)
    # (i.e., they are not generated by a change on screen, so they are not affected by this delay)
    # the events that are affected are:
    #    when fixation cross appears (TRIGGER 93)
    #    when the sentence appears (TRIGGER 94)
    #    when the sentence disappears (TRIGGER 95)
    #    when the calibration screen is presented (we ignore that by aligning the triggers)
    # alternatively we might ignore this problem and get the stimuli even before, it should
    # not matter for covariance matrix
    
    evt.apply(lambda x: x['time']+34 if x['trigger'] in [93, 94, 95] else x['time'], axis=1)
    
    event_dict = {'Stim_on': 94}
    
    epochs = mne.Epochs(raw_test, evt, tmin=-0.350, tmax=-0.150, event_id=event_dict,
                        baseline=(-0.350, -0.150),
                        flat=None, picks=picks, reject_by_annotation=False, 
                        reject=None, preload=True)

    noise_cov = mne.compute_covariance(epochs, method=cov_method, 
                                                tmax=-0.150, rank='info', return_estimators=True)
    if cov_method=='empirical':
        noise_cov = mne.cov.regularize(noise_cov, epochs.info, mag=0.1, grad=0.1,
                                   eeg=0.1, rank='info')

    if save_covmat:
        fname_cov = path.join(sbj_path, config.map_subjects[sbj_id][0][-3:] + \
                              f"_covariancematrix_{cov_method}-cov.fif")
        mne.write_cov(fname_cov, noise_cov, overwrite=True)
    if plot_covmat:
        if cov_method=='auto':
            figs = noise_cov[0].plot(epochs.info, proj=True)
        else:
            figs = noise_cov.plot(epochs.info, proj=True)
        for i, fig in zip(['matrix', 'eigenvalue_index'], figs):
            fname_fig = path.join(sbj_path, 'Figures', f'covariance_{cov_method}_{i}.png')
            fig.savefig(fname_fig)
    
            figs = noise_cov.plot(epochs.info, proj=True)
            plt.show()
            for i, fig in zip(['matrix', 'eigenvalue_index'], figs):
                fname_fig = f'/imaging/hauk/users/fm02/MEG_NEOS/data/misc/empirical_covariance/{subject}_covariance_{i}.png'
                fig.savefig(fname_fig)
    
            evoked = epochs.average()
            fig = evoked.plot_white(noise_cov, time_unit='s')
            fname_fig = f'/imaging/hauk/users/fm02/MEG_NEOS/data/misc/empirical_covariance/{subject}_whitened_empirical.png'
            fig.savefig(fname_fig)


# if len(sys.argv) == 1:

#     sbj_ids = [1,2,3,5,6,8,9,10,11,12,13,14,15,16,17,18,19,
#                21,22,23,24,25,26,27,28,29,30]


# else:

#     # get list of subjects IDs to process
#     sbj_ids = [int(aa) for aa in sys.argv[1:]]


# for ss in sbj_ids:
#     compute_covariance(ss)    
    
# this was used to check the epoch duration, keeping it for record
# and in case it's useful in the future     
    # fix_on = np.where(evt['trigger']==93)[0]
    # fix_off = np.where(evt['trigger']==94)[0]
             
    
    # for i in range(len(fix_off)):
    #     if fix_off[i]-fix_on[i] != 1:
    #         fix_on = np.delete(fix_on, i)
    
    # fix_times = tuple(zip(fix_on, fix_off)) 
   
    # fix_selection = dict.fromkeys(['data', 'time'])
    # fix_selection['data'] = list()
    # fix_selection['time'] = list()
    
    # for i, indices in enumerate(fix_times):
    #     # adding -20 ms prior to saccade onset and +10ms after saccade offset
    #     # 20 is fine as long as th
    #     d, t = raw[:,(evt.iloc[indices[0]][0] - t0) : \
    #                     (evt.iloc[indices[1]][0] - t0)]
    #     # mean centre each saccade epoch
    #     d -= d.mean(axis=1).reshape(-1,1)    
    #     fix_selection['data'].append(d)    
    #     fix_selection['time'].append(t) 



    # fix_concatenated = np.concatenate(fix_selection['data'], axis=1)
    
    # num.append(pd.Series([trial.shape[1] for trial in fix_selection['data']]))
        
        # transform to Raw object
    # data_for_cov = mne.io.BaseRaw(info=raw.info, preload=fix_concatenated)
